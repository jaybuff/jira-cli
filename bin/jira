#!/usr/bin/env perl

use strict;
use warnings;

use File::Temp;
use Getopt::Long;
use YAML::Syck;
use Digest::MD5;
use LWP::UserAgent;
use HTTP::Request;
use HTTP::Headers;
use HTTP::Cookies;

my %opts = (
    type => 'Bug',
    user => $ENV{USER},
    baseuri => "http://jira",
);

my %overrides = ();
GetOptions(
    'project=s'     => \$overrides{project},
    'component=s'   => \$overrides{component},
    'type=s'        => \$overrides{type},
    'user=s'        => \$overrides{user},
    'summary=s'     => \$overrides{summary},
    'description=s' => \$overrides{description},
);

load_configs(\%opts);
while( my ($k,$v) = each %overrides ) {
    $opts{$k} = $v if defined $v;
    if( ! defined $opts{$k} ) {
        $opts{$k} = "";
    }
}

my ($fh, $fn) = File::Temp::tempfile("jiraXXXXXX",
  SUFFIX => ".yml",
  TMPDIR => 1,
  CLEANUP => 1, # TODO make this a config option for debugging
);

print $fh <<EOM;
summary: $opts{summary}
--- | # description on next line
$opts{description}
---
project: $opts{project}
component: $opts{component}
issuetype: $opts{type}
assignee: $opts{user}
reporter: $opts{user}
EOM

close $fh;

my $jira = parse_jira(user_edit_file($fn));

use Data::Dumper;
print Dumper $jira;

my $ua = Jira::UserAgent->new(
    cookie_jar => HTTP::Cookies->new(
        file => "$ENV{HOME}/.$opts{user}-cookies.txt",
        autosave => 1,
    ),
);

use JSON::Syck;
my $headers = HTTP::Headers->new();
$headers->header("Content-Type" => "application/json");
$headers->header("Accept" => "application/json");
my $req = HTTP::Request->new("POST", "$opts{baseuri}/rest/api/2/issue", $headers, JSON::Syck::Dump($jira));
print "REQUEST:\n";
print $req->as_string;

my $resp = $ua->request($req);
# need to log in (ie set Basic Auth headers)
if( $resp->header("X-AUSERNAME") eq 'anonymous' ) {
    $ua->auth($req);
    print "REQUEST:\n";
    print $req->as_string;
    $resp = $ua->request($req);
    save_cookies();
}

print "RESPONSE:\n";
print $resp->as_string;

# should get somethign like: {"id":"12345","key":"PROJECT-123","self":"http://jira/rest/api/2/issue/12345"}
my $issue = $resp->decoded_content;

my $data = JSON::Syck::Load($issue);

print "OK: $data->{key} [$opts{baseuri}/browse/$data->{key}]\n";


# give content that represents a jira in YAML format, convert it to a hash ref
# and return it.  If there multiple YAML documents are present, merge them
#
# the last YAML document that is a scalar is put into a key named description
# unless a key of that name is explicitly present
sub parse_jira {
  my $content = shift;

  my @yamls = eval {
    YAML::Syck::Load($content);
  };
  if ($@) {
    die "Invalid jira specification (not valid yaml): $@\n";
  }

  my %jira = ();
  foreach my $yaml (@yamls) {
    if (ref($yaml) eq "HASH") {
      @jira{ keys %$yaml } = values %$yaml;
    } elsif (!ref($yaml)) {
      $jira{"description"} = $yaml;
    }
  }

  my %formats = (
      assignee   => '{ "name" => "%s" }',
      reporter   => '{ "name" => "%s" }',
      issuetype  => '{ "name" => "%s" }',
      project    => '{ "key" => "%s" }',
      component  => ["components" => '[ { "name" => "%s" } ]'],
      summary => '"%s"',
      description => '"%s"',
  );

  for my $key ( keys %jira ) {
      my $fmt = $formats{$key};
      die "format for $key not found\n" unless $fmt;
      if( ref($fmt) eq 'ARRAY') {
          my $val = delete $jira{$key};
          $jira{$fmt->[0]} = eval sprintf($fmt->[1], $val);
      } else {
          $jira{$key} = eval sprintf($fmt, $jira{$key});
      }
  }
  return { fields => \%jira };
}

# dies if the user makes no changes to the file or the editor returns non-zero
# returns the contents of the file that user created
sub user_edit_file {
  my $file = shift;

  my $digest_before = Digest::MD5::md5_hex(slurp($file));

  my $editor = $ENV{EDITOR} || "vi";
  my $ret = system($editor, $file);
  if ($ret != 0) {
    die "Aborting: $editor $file returned $ret\n";
  }

  my $contents = slurp($file);
  if (Digest::MD5::md5_hex($contents) eq $digest_before) {
    die "Aborting: unchanged file\n";
  }

  return $contents;
}

sub slurp {
  my $file = shift;
  local $/ = undef;
  open my $fh, $file or die "Couldn't open $file: $!";
  return <$fh>
}

sub save_cookies {
    $ua->cookie_jar->scan(
        sub {
            my @args = @_;
            # dont discard cookies, so we dont get prompted for a password everytime
            $args[9] = 0;
            $ua->cookie_jar->set_cookie(@args);
        }
    );
    return;
}

use Cwd;
use File::Basename;

sub load_configs {
    my $opts = shift;
    my $dir = cwd();
    my @configs = ();
    while( $dir ne '/' ) {
        my $f = "$dir/.jira";
        push @configs, $f if -f $f;
        $dir = File::Basename::dirname($dir);
    }
    push @configs, "/etc/jira-cli.yml" if -f "/etc/jira-cli.yml";
    for my $c ( reverse @configs ) {
        my $conf = -x $c ? YAML::Syck::Load(qx{$c}) : YAML::Syck::LoadFile($c);
        for my $key ( %$conf ) {
            $opts->{$key} = $conf->{$key};
        }
    }
}

package Jira::UserAgent;
use base qw(LWP::UserAgent);
use MIME::Base64;

sub auth {
    my ($self, $req) = @_;
    my $user = $opts{user};
    my $pass = password();
    my $encoded = MIME::Base64::encode_base64("$user:$pass");
    $req->header("Authorization" => "Basic $encoded");
}

our @CLEANUP;
sub password {
    my ($in, $out) = stdio();

    my $old = select $out;
    eval "use Term::ReadKey";
    if( $@ ) {
        # no readkey, so try for stty to turn off echoing
        my ($sttyBin) = grep { -x $_ } qw(/bin/stty /usr/bin/stty);
        if( $sttyBin ) {
            push @CLEANUP, sub {
                system($sttyBin, "echo");
            };
            system($sttyBin, "-echo");
        }
        else {
            die "Unable to disable echo on your tty while reading password, aborting";
        }
    }
    else { 
        # use readkey to turn off echoing
        push @CLEANUP, sub {
            Term::ReadKey::ReadMode("restore", $out);
        };
        Term::ReadKey::ReadMode("noecho", $out);
    }
    print $out "Jira Password [$opts{user}]: ";
    my $pass = <$in>;
    $CLEANUP[-1]->();
    print $out "\n";
    chomp($pass);
    select $old;
    return $pass;
}

sub stdio {
    my ($in, $out);
    if( !-t STDIN || !-t STDOUT ) {
        # stdio missing, so try to use tty directly
        my $tty = "/dev/tty" if -e "/dev/tty";
        if( !$tty ) {
            my ($ttyBin) = grep { -x $_ } qw(/bin/tty /usr/bin/tty);
            if ( $ttyBin ) {
                $tty = qx{$ttyBin};
                chomp($tty);
            }
        }
        
        if( !$tty ) {
            die "Could not determine TTY to read password from, aborting";
        }
        open $in,  "<$tty" or die "Failed to open tty $tty for input: $!";
        open $out, ">$tty" or die "Failed to open tty $tty for output: $!";
    }
    else {
        # using stdio
        $in  = \*STDIN;
        $out = \*STDOUT;
    }
    return ($in, $out);
}

END { 
    for my $cleaner ( @CLEANUP ) {
        $cleaner->();
    }
}
